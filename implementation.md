# 주 함수

주 함수는 다음과 같이 동작한다:

- 해석기를 실행하여 티켓 묶음을 생성한다.
  - 실행 중 오류가 발생할 시 음의 정수를 반환한다.
- 티켓 묶음을 출력기에 입력한다.
  - 출력기가 음의 정수를 반환할 시 음의 정수를 반환한다.
  - 출력기가 출력한 문자 개수를 반환할 시 이를 반환한다.

# 데이터 형식

"티켓"은 다음과 같이 표현한다.

```c
typedef struct s_conv
{
	int		i_conv;			// 수행할 변환의 번호
	char	*s;				// format에서 해당 변환의 시작점
	char	*e;				// format에서 해당 변환의 시작점
	int		minwidth;		// 최소 너비 값
	int		precision;		// 정밀도 값
	int		f_minwidth;		// 최소 너비 적용 여부
	int		f_left;			// [-] 좌측 정렬 여부
	int		f_zeropad;		// [0] 패딩을 0으로 쓸 것인지 여부
	int		f_precision;	// [.] 정밀도 적용 여부
	int		f_altform;		// [#] 대체 형태 적용 여부
	int		f_blank;		// [ ] 양의 부호 자리에 공백 출력 여부
	int		f_sign;			// [+] 양의 부호 출력 여부
}	t_conv;
```

수행할 변환의 번호는 다음과 같은 열거형에서 정의한다.

```c
enum e_conv
{
	PLAIN = 0,
	CHAR,
	STR,
	PTR,
	SDEC,
	UDEC,
	LHEX,
	UHEX,
	PCENT
};
```

- `PLAIN = 0`: `format` 문자열의 특정 부분을 변환 없이 그대로 출력할 것을 지시한다.
- `CHAR = 1`: `c` 변환에 해당한다.
- `STR = 2`: `s` 변환에 해당한다.
- `PTR = 3`: `p` 변환에 해당한다.
- `SDEC = 4`: `d`, `i` 변환에 해당한다.
- `UDEC = 5`: `u` 변환에 해당한다.
- `LHEX = 6`: `x` 변환에 해당한다.
- `UHEX = 7`: `X` 변환에 해당한다.
- `PCENT = 8`: `%` 변환에 해당한다.

# 해석기

- `format` 문자열의 각 원소를 가리키는 커서를 생성한다.
- 커서가 `\0`에 도달할 때까지 반복한다:
  - 커서가 현재 `%`에 있다면:
    - **형식 문자열 해석기**를 실행한다.
      - 이때 **형식 문자열 해석기**는 자신이 파싱을 완료한 지점까지 커서를 이동시켜놓는다.
  - 커서가 현재 `%`이 아닌 문자에 있다면:
    - `%`을 가리킬 때 까지 커서를 앞으로 옮긴다.
    - 원래 커서가 있던 자리부터 커서가 멈춘 자리까지 출력할 것을 지시하는 티켓을 리스트 끝에 추가한다.

> `PLAIN` 변환에서 `t_conv.s`와 `t_conv.e`를 지정하는 규칙
> ```
> "Hello, %s!"
>  0123456789
> ```
> 위 문자열에서 `Hello, ` 부분이 `PLAIN` 변환에 해당된다. 이때 변환할 부분은 `H`(0번)에서 ` `(6번)까지이다.
> 그러므로 티켓에서 `t_conv.s`는 `H`를 가리키도록 (즉 `format + 0`) 설정한다. 하지만 `t_conv.e`는 ` `를 가리키도록 (즉 `format + 6`) 설정하지 않고, 그 다음 문자인 `%`를 가리키도록 (즉 `format + 7`) 한다.
> 이렇게 하면 `e - s` 연산으로 출력할 문자열의 길이를 알아낼 수 있고, `while (s != e) write(fd, s++, 1);` 등의 문장으로 전체를 출력할 수 있는 등 표현이 간결해진다.
> 이외의 변환에서는 `t_conv.s`와 `t_conv.e`가 특별한 의미를 가지지 않는다.

## 형식 문자열 해석기

```
%{플래그: #0- +}{최소 너비: 숫자}{정밀도: .과 숫자들}{변환 지정자: [cspdiuxX%]}
```

- 빈 티켓 (`t_conv`)을 하나 생성한다.
- `f_altform`, `f_blank`, `f_sign`, `f_left`, `f_zeropad`: 각 플래그의 유무를 확인하고 이를 티켓에 기록한다.
  - 플래그에 해당하는 문자 `# +-0`가 아닌 문자가 출현할 때까지 커서를 앞으로 옮긴다. 마주친 플래그를 켠다.
- `f_minwidth`: 최소 너비가 지정되어 있는지 확인하고 지정되었다면 그 값을 해석하여 티켓에 기록한다.
  - 커서가 숫자를 가리키고 있다면 최소 너비가 지정된 것이다.
  - 숫자가 아닌 문자를 마주칠 때까지 커서를 앞으로 옮긴다. 
  - `minwidth`: 숫자가 끝나는 지점까지의 문자열을 `atoi`로 변환한 결과가 최소 너비다. 
- `f_precision`: 정밀도가 지정되어 있는지 확인하고 지정되었다면 그 값을 해석하여 티켓에 기록한다.
  - 커서가 `.`을 가리킨다면 정밀도가 지정된 것이다.
  - 숫자가 아닌 문자를 마주칠 때까지 커서를 앞으로 이동한다.
  - `precision`: 숫자가 발견되지 않았다면 정밀도는 `0`이고, 숫자가 존재할 경우 `atoi`로 정밀도를 획득한다. 
- `i_conv`: 어떤 변환 지정자가 지정되어 있는지 확인하고 이를 티켓에 기록한다. 
- 위 과정 중 등장하면 안되는 문자가 등장하거나 오류가 발생할 시 티켓은 폐기된다.
  - 모든 것이 정상 작동할 시 티켓을 리스트 끝에 추가한다.

# 출력기

티켓 연결 리스트(`t_list`)를 처음부터 끝까지 출력하는 **리스트 출력기**가 있고, 티켓 하나만을 출력하는 **티켓 출력기**가 있다. `plain`, `c`, `s`, `p`, `d`, `i`, `u`, `x`, `X`, `%`에 대한 출력 방식이 모두 다르기 때문에 각각에 대한 출력기가 따로 필요하다.

## 리스트 출력기

리스트 출력기는 단순히 티켓 리스트를 끝까지 순회하며 각 티켓이 요구하는 출력기를 호출하고 결과를 수집한다. 중간에 개별 호출기가 오류를 반환할 경우 출력은 중지되고 오류 코드를 반환한다. 모든 출력이 성공적으로 종료될 경우 각 출력기가 보고한 출력한 문자 개수를 합산하여 반환한다.

## 티켓 출력기

티켓 출력기는 다음과 같이 동작한다:

- 변환이 필요하지 않은 티켓이라면 `format` 문자열에서 해당 부분을 그대로 출력한다.
- 변환이 필요하다면:
  - 가변 인자에서 필요한 타입의 변수를 하나 소모한다.
  - 해당 변수를 티켓에서 요구하는대로 변환하여 문자열에 저장한다.
  - 문자열을 `STDOUT`에 `write()`한다. 이때
    - I/O 관련 오류 발생 시 음의 정수를 반환한다.
    - 오류 없이 작업 완료 시 문자열의 길이를 반환한다.

이때 빈 문자열을 생성한 후 필요한 요소를 붙여 나가며 변환을 수행하게 된다. 필요한 요소에는 다음과 같은 요소가 있다.

- 접두사 (prefix)

> 접두사는 숫자 변환(`pdiuxX`)에 출현하는 요소다. 
> 접두사는 부호, 16진수 표시자, 정밀도 표시자로 이루어진다.
> - 부호는 다음 규칙에 따라 생성한다.
>   - 음수에는 `-`을 표기한다.
>   - 양수일 경우, `di` (또는 `SDEC`)변환이 아닐 경우 부호를 표기하지 않는다.
>     - `di`일 경우
>       - `f_sign`이 켜졌을 시 `+`를 표기한다.
>       - `f_blank`가 켜졌을 시 ` `를 표기한다.
>       - 해당되는 경우가 없을 시 부호를 표기하지 않는다.
> - 16진수 표시자는
>   - `p` 변환에서 `0x`로 표기한다.
>   - `xX` 변환에서 `0`이 아닌 수를 변환할 때 대소문자에 따라 `0x` 또는 `0X`로 표기한다.
> - 정밀도 표시자는 `f_precision`이 켜져 있고 숫자의 길이가 `precision`보다 짧을 경우 그 차만큼 `0`을 반복하여 표기한다.

- 여백 (padding)

> 여백에는 공백(` `)과 `0`의 2종류가 있다. 
> `f_minwidth` 플래그가 켜져 있고 출력할 문자열의 총 길이가 이보다 짧을 시 여백이 필요하다.
> - `f_zeropad` 플래그가 켜져 있고, `f_precision` 플래그가 꺼져 있고, `f_left` 플래그가 꺼져 있을 시 여백에 `0`을 채운다. 그렇지 않을 시 ` `을 채운다.

- 주부

> 변수를 문자열로 변환한 결과이다.
> 부호나 자릿수 관련 사항은 여백과 접두사에 일임하므로 정수 변환 시 부호 여하를 막론하고 숫자만 사용하여 변환한다.
> 문자열의 경우 `f_precision`의 적용에 따라 길이를 제한한 결과이다.

이때 변환의 종류와 설정된 플래그의 조합에 따라 요소의 출력 순서가 달라지기 때문에 먼저 모든 요소의 생성을 완료한 뒤 이를 올바른 순서에 따라 병합한 후 한번에 출력하는 것이 간단한 방법이다.

### 요소 생성기

구현의 용이성을 위해 **출력기**와 별개로 **요소 생성기**를 구현한다. **요소 생성기**는 **출력기**처럼 티켓과 변수를 입력받아 상기된 규칙대로 문자열 요소를 생성한다. 다만 이를 `STDOUT`에 출력할 권한은 없으며 요소의 연결과 출력은 **출력기**가 전담한다.

- N개의 문자가 반복되는 문자열 생성기
- 부호 없는 숫자의 문자열 생성기
- 접두사 생성기
- 여백 생성기

### 요소 연결기

여백, 접두사, 주부의 연결 논리는 변화무쌍하고 복잡하다. 이것을 출력기에 포함시키기보다는 각 상황에 적합한 연결기를 고안하고 출력기가 이를 호출할 수 있도록 하는 것이 응집도 향상에 유리하다.

- 숫자 연결기

> `diuxX` 변환에서 여백, 접두사, 주부를 연결한다.
> - 여백이 존재하고 `0`으로 이루어졌을 경우 접두사, 여백, 주부 순서로 연결한다.
> - 이외의 경우, `f_left`가 켜져 있을 경우

### plain 출력기

해석기가 명시한대로 `t_conv.s`부터 `t_conv_e` 전까지 `format`의 내용을 그대로 출력한다.

```c
return (write(fd, conv->s, conv->e - conv->s));
```
처럼 `write()`의 반환값을 그대로 반환하여도 무방하다.

### c 출력기

- 최소 너비 플래그가 지정되어 있고 그 값이 1보다 클 시
  - 그 차만큼 공백을 출력해야 한다.
    - 좌측 정렬 플래그가 지정되어 있을 시:
      - `char` 하나를 출력하고 공백을 출력한다.
    - 그렇지 않을 시:
      - 공백을 출력하고 `char` 하나를 출력한다.
- 해당하지 않을 시 공백을 출력한다.

> s 출력기에 길이가 1인 문자열을 입력하는 방식으로 구현할 경우 `\0`을 처리할 수 없다.

### s 출력기

- 제공받은 문자열이 `NULL`일 시 `(null)`을 대신 출력한다.
- 정밀도 플래그가 지정되어 있고 이가 문자열 길이보다 짧을 시 원 문자열을 절단하여 주부를 생성한다.
  - 그렇지 않을 시 원 문자열이 주부가 된다.
- 상기된 규칙에 따라 여백을 생성하고 주부와 연결한다.
- 